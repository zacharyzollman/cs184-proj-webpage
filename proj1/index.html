<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>My Website</title>
    <link rel="stylesheet" href="./style.css">
    <link rel="icon" href="./favicon.ico" type="image/x-icon">
  </head>
  <body>
    <main>
		<h1 class="center">Project 1: Rasterizer</h1>
		<p class="center">Abdul Ali Khan, Zachary Zollman</p>

		<!-- centered subheading -->
		<h2 class="center">Task 1: Drawing Single-Color Triangles</h2>

    To rasterize a triangle, we first find the bounding box of the triangle by calculating the minimum and maximum x and y values of the three vertices. Then we iterate through each pixel in the bounding box and perform a three-line test to check if the pixel is inside the triangle. If the pixel is inside the triangle, we fill the pixel with the specified color.

    <br></br>
    The three-line test involves calculating the signed areas of three sub-triangles formed by the pixel and two vertices of the triangle. If the signed areas have the same sign, then the pixel is inside the triangle. We also add a half-pixel offset to the coordinates when filling the pixel to ensure that the pixel is correctly centered within the bounding box. This is the basic approach to triangle rasterization without supersampling.

    <code>
      <br>
      // TODO: Task 1: Implement basic triangle rasterization here, no supersampling<br>
      <br>
      
   // find the bounding box of the triangle<br>
   int minX = min(x0, min(x1, x2));<br>
   int maxX = max(x0, max(x1, x2));<br>
   int minY = min(y0, min(y1, y2));<br>
   int maxY = max(y0, max(y1, y2));<br>


   // iterate through the bounding box<br>
   for (int x = minX; x <= maxX; x++)<br>
   {<br>
     for (int y = minY; y <= maxY; y++)<br>
     {<br>


       //three line test to see if the point is inside the triangle<br>
       float d1 = (x - x1) * (y0 - y1) - (x0 - x1) * (y - y1);<br>
       float d2 = (x - x2) * (y1 - y2) - (x1 - x2) * (y - y2);<br>
       float d3 = (x - x0) * (y2 - y0) - (x2 - x0) * (y - y0);<br>
      
       // if the point is inside the triangle, fill the pixel<br>
       if ((d1 >= 0 && d2 >= 0 && d3 >= 0) || (d1 <= 0 && d2 <= 0 && d3 <= 0))<br>
       {<br>
         fill_pixel(x + 0.5, y + 0.5, color);<br>
       }<br>
     }<br>
   }<br>
    </code>

    The given algorithm uses a bounding box to define the potential area of the triangle and iterates through each pixel within the bounding box to determine whether it is inside or outside of the triangle. As such, it covers every pixel within the bounding box, and therefore, it can't miss any pixels inside the triangle.
Therefore, the given algorithm is no worse than one that checks each sample within the bounding box of the triangle, and it provides a reasonable trade-off between computational efficiency and accuracy.
<br><br>
    TODO: image

		<h2 class="center">Task 2: Antialiasing by Supersampling</h2>

    Supersampling involves sampling your model multiple times per pixel, rather than just once per pixel. This is useful because it can reduce undesired behaviors that arise from sampling only once per sample, such as jaggies. By sampling multiple times, we can select a more representative pixel color. In particular, on edges, we can average the triangle color with the background/surrounding color. Thus, there isn’t a triangle present/triangle absent binary, but rather a gradual transition between the triangle’s color and its surroundings.<br>
    In order to antialias our triangles, we increased the size of our sample buffer so that we could store one color per sample. In order to achieve this, we modified the sample_buffer.resize() calls in set_sample_rate and set_framebuffer_target to set the size to width * height * sample_rate. We also modified the rasterize_triangle function to be able to sample multiple points within the given pixel. The samples are evenly spaced in a sort of mini-grid within the grid of pixels. As we move through the grids using for loops, we set the color in the sample buffer to be the triangle color if it is within the triangle. We modified resolve_to_framebuffer so that it could take in multiple sample colors from the sample buffer to determine a single pixel color. Specifically, we averaged the color values. This involved summing the RGB values for each color and dividing by the number of colors. We implemented supersampling for triangles, but we still wanted lines and points to render appropriately, so we modified fill_pixel to fill all corresponding samples in the sample buffer with the desired color. That way, when the corresponding samples were averaged to determine the color for the pixel, they averaged to the desired color.

    <br><br>
    TODO: image

		<h2 class="center">Task 3: Transforms</h2>

    TODO: image
    <br><br>
    The cubeman is mid-somersault, trying to get into a handstand to then swing his legs around underneath himself. I have changed the body color by adding blue tiles to give him more motion.

		<h2 class="center">Task 4: Barycentric coordinates</h2>

    TODO: triangle image
    <br><br>
    Barycentric coordinates are a way to represent a point inside a triangle as a linear combination of the triangle's vertices. The coordinates are determined by computing the ratios of the areas of three smaller triangles formed by the point and each of the triangle's edges, to the area of the entire triangle. These ratios represent the weights assigned to each vertex to calculate the position of the point. 
    <br><br>
    Barycentric coordinates are simply a set of numbers that describe a linear combination of vertices of a given triangle.
    For △ABC, if P=(α,β,γ), where α+β+γ=1, and A, B, C each has an associated value, then P=αA+βB+γC
    
    <br><br>
    TODO: color wheel image

		<h2 class="center">Task 5: "Pixel sampling" for texture mappings</h2>
		<h2 class="center">Task 6: "Level sampling" with mipmaps for texture mapping</h2>

    Link to write-up: <a href="https://zacharyzollman.github.io/cs184-proj-webpage/proj1/index.html">https://zacharyzollman.github.io/cs184-proj-webpage/proj1/index.html</a>
    </main>
	<script src="index.js"></script>
  </body>
</html>